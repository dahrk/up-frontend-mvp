{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* istanbul ignore file: deprecated */\n\nconst url_1 = require(\"url\");\n\nconst keys = ['protocol', 'host', 'hostname', 'port', 'pathname', 'search'];\n\nexports.default = (origin, options) => {\n  var _a, _b;\n\n  if (options.path) {\n    if (options.pathname) {\n      throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');\n    }\n\n    if (options.search) {\n      throw new TypeError('Parameters `path` and `search` are mutually exclusive.');\n    }\n\n    if (options.searchParams) {\n      throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');\n    }\n  }\n\n  if (options.search && options.searchParams) {\n    throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');\n  }\n\n  if (!origin) {\n    if (!options.protocol) {\n      throw new TypeError('No URL protocol specified');\n    }\n\n    origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;\n  }\n\n  const url = new url_1.URL(origin);\n\n  if (options.path) {\n    const searchIndex = options.path.indexOf('?');\n\n    if (searchIndex === -1) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.slice(0, searchIndex);\n      options.search = options.path.slice(searchIndex + 1);\n    }\n\n    delete options.path;\n  }\n\n  for (const key of keys) {\n    if (options[key]) {\n      url[key] = options[key].toString();\n    }\n  }\n\n  return url;\n};","map":{"version":3,"sources":["/home/td/code/up-frontend-mvp/node_modules/got/dist/source/core/utils/options-to-url.js"],"names":["Object","defineProperty","exports","value","url_1","require","keys","default","origin","options","_a","_b","path","pathname","TypeError","search","searchParams","protocol","hostname","host","url","URL","searchIndex","indexOf","slice","key","toString"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;AACA,MAAMC,KAAK,GAAGC,OAAO,CAAC,KAAD,CAArB;;AACA,MAAMC,IAAI,GAAG,CACT,UADS,EAET,MAFS,EAGT,UAHS,EAIT,MAJS,EAKT,UALS,EAMT,QANS,CAAb;;AAQAJ,OAAO,CAACK,OAAR,GAAkB,CAACC,MAAD,EAASC,OAAT,KAAqB;AACnC,MAAIC,EAAJ,EAAQC,EAAR;;AACA,MAAIF,OAAO,CAACG,IAAZ,EAAkB;AACd,QAAIH,OAAO,CAACI,QAAZ,EAAsB;AAClB,YAAM,IAAIC,SAAJ,CAAc,0DAAd,CAAN;AACH;;AACD,QAAIL,OAAO,CAACM,MAAZ,EAAoB;AAChB,YAAM,IAAID,SAAJ,CAAc,wDAAd,CAAN;AACH;;AACD,QAAIL,OAAO,CAACO,YAAZ,EAA0B;AACtB,YAAM,IAAIF,SAAJ,CAAc,8DAAd,CAAN;AACH;AACJ;;AACD,MAAIL,OAAO,CAACM,MAAR,IAAkBN,OAAO,CAACO,YAA9B,EAA4C;AACxC,UAAM,IAAIF,SAAJ,CAAc,gEAAd,CAAN;AACH;;AACD,MAAI,CAACN,MAAL,EAAa;AACT,QAAI,CAACC,OAAO,CAACQ,QAAb,EAAuB;AACnB,YAAM,IAAIH,SAAJ,CAAc,2BAAd,CAAN;AACH;;AACDN,IAAAA,MAAM,GAAI,GAAEC,OAAO,CAACQ,QAAS,KAAI,CAACN,EAAE,GAAG,CAACD,EAAE,GAAGD,OAAO,CAACS,QAAd,MAA4B,IAA5B,IAAoCR,EAAE,KAAK,KAAK,CAAhD,GAAoDA,EAApD,GAAyDD,OAAO,CAACU,IAAvE,MAAiF,IAAjF,IAAyFR,EAAE,KAAK,KAAK,CAArG,GAAyGA,EAAzG,GAA8G,EAAG,EAAlJ;AACH;;AACD,QAAMS,GAAG,GAAG,IAAIhB,KAAK,CAACiB,GAAV,CAAcb,MAAd,CAAZ;;AACA,MAAIC,OAAO,CAACG,IAAZ,EAAkB;AACd,UAAMU,WAAW,GAAGb,OAAO,CAACG,IAAR,CAAaW,OAAb,CAAqB,GAArB,CAApB;;AACA,QAAID,WAAW,KAAK,CAAC,CAArB,EAAwB;AACpBb,MAAAA,OAAO,CAACI,QAAR,GAAmBJ,OAAO,CAACG,IAA3B;AACH,KAFD,MAGK;AACDH,MAAAA,OAAO,CAACI,QAAR,GAAmBJ,OAAO,CAACG,IAAR,CAAaY,KAAb,CAAmB,CAAnB,EAAsBF,WAAtB,CAAnB;AACAb,MAAAA,OAAO,CAACM,MAAR,GAAiBN,OAAO,CAACG,IAAR,CAAaY,KAAb,CAAmBF,WAAW,GAAG,CAAjC,CAAjB;AACH;;AACD,WAAOb,OAAO,CAACG,IAAf;AACH;;AACD,OAAK,MAAMa,GAAX,IAAkBnB,IAAlB,EAAwB;AACpB,QAAIG,OAAO,CAACgB,GAAD,CAAX,EAAkB;AACdL,MAAAA,GAAG,CAACK,GAAD,CAAH,GAAWhB,OAAO,CAACgB,GAAD,CAAP,CAAaC,QAAb,EAAX;AACH;AACJ;;AACD,SAAON,GAAP;AACH,CAxCD","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* istanbul ignore file: deprecated */\nconst url_1 = require(\"url\");\nconst keys = [\n    'protocol',\n    'host',\n    'hostname',\n    'port',\n    'pathname',\n    'search'\n];\nexports.default = (origin, options) => {\n    var _a, _b;\n    if (options.path) {\n        if (options.pathname) {\n            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');\n        }\n        if (options.search) {\n            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');\n        }\n        if (options.searchParams) {\n            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');\n        }\n    }\n    if (options.search && options.searchParams) {\n        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');\n    }\n    if (!origin) {\n        if (!options.protocol) {\n            throw new TypeError('No URL protocol specified');\n        }\n        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;\n    }\n    const url = new url_1.URL(origin);\n    if (options.path) {\n        const searchIndex = options.path.indexOf('?');\n        if (searchIndex === -1) {\n            options.pathname = options.path;\n        }\n        else {\n            options.pathname = options.path.slice(0, searchIndex);\n            options.search = options.path.slice(searchIndex + 1);\n        }\n        delete options.path;\n    }\n    for (const key of keys) {\n        if (options[key]) {\n            url[key] = options[key].toString();\n        }\n    }\n    return url;\n};\n"]},"metadata":{},"sourceType":"script"}