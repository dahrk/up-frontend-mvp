{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst PCancelable = require(\"p-cancelable\");\n\nconst types_1 = require(\"./types\");\n\nconst parse_body_1 = require(\"./parse-body\");\n\nconst core_1 = require(\"../core\");\n\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\n\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\n\nconst is_response_ok_1 = require(\"../core/utils/is-response-ok\");\n\nconst proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];\n\nfunction asPromise(normalizedOptions) {\n  let globalRequest;\n  let globalResponse;\n  const emitter = new events_1.EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    const makeRequest = retryCount => {\n      const request = new core_1.default(undefined, normalizedOptions);\n      request.retryCount = retryCount;\n      request._noPipe = true;\n      onCancel(() => request.destroy());\n      onCancel.shouldReject = false;\n      onCancel(() => reject(new types_1.CancelError(request)));\n      globalRequest = request;\n      request.once('response', async response => {\n        var _a;\n\n        response.retryCount = retryCount;\n\n        if (response.request.aborted) {\n          // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n          return;\n        } // Download body\n\n\n        let rawBody;\n\n        try {\n          rawBody = await get_buffer_1.default(request);\n          response.rawBody = rawBody;\n        } catch (_b) {\n          // The same error is caught below.\n          // See request.once('error')\n          return;\n        }\n\n        if (request._isAboutToError) {\n          return;\n        } // Parse body\n\n\n        const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n        const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n        const {\n          options\n        } = request;\n\n        if (isCompressed && !options.decompress) {\n          response.body = rawBody;\n        } else {\n          try {\n            response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n          } catch (error) {\n            // Fallback to `utf8`\n            response.body = rawBody.toString();\n\n            if (is_response_ok_1.isResponseOk(response)) {\n              request._beforeError(error);\n\n              return;\n            }\n          }\n        }\n\n        try {\n          for (const [index, hook] of options.hooks.afterResponse.entries()) {\n            // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n            // eslint-disable-next-line no-await-in-loop\n            response = await hook(response, async updatedOptions => {\n              const typedOptions = core_1.default.normalizeArguments(undefined, { ...updatedOptions,\n                retry: {\n                  calculateDelay: () => 0\n                },\n                throwHttpErrors: false,\n                resolveBodyOnly: false\n              }, options); // Remove any further hooks for that request, because we'll call them anyway.\n              // The loop continues. We don't want duplicates (asPromise recursion).\n\n              typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n\n              for (const hook of typedOptions.hooks.beforeRetry) {\n                // eslint-disable-next-line no-await-in-loop\n                await hook(typedOptions);\n              }\n\n              const promise = asPromise(typedOptions);\n              onCancel(() => {\n                promise.catch(() => {});\n                promise.cancel();\n              });\n              return promise;\n            });\n          }\n        } catch (error) {\n          request._beforeError(new types_1.RequestError(error.message, error, request));\n\n          return;\n        }\n\n        if (!is_response_ok_1.isResponseOk(response)) {\n          request._beforeError(new types_1.HTTPError(response));\n\n          return;\n        }\n\n        globalResponse = response;\n        resolve(request.options.resolveBodyOnly ? response.body : response);\n      });\n\n      const onError = error => {\n        if (promise.isCanceled) {\n          return;\n        }\n\n        const {\n          options\n        } = request;\n\n        if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n          const {\n            response\n          } = error;\n          resolve(request.options.resolveBodyOnly ? response.body : response);\n          return;\n        }\n\n        reject(error);\n      };\n\n      request.once('error', onError);\n      const previousBody = request.options.body;\n      request.once('retry', (newRetryCount, error) => {\n        var _a, _b;\n\n        if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n          onError(error);\n          return;\n        }\n\n        makeRequest(newRetryCount);\n      });\n      proxy_events_1.default(request, emitter, proxiedRequestEvents);\n    };\n\n    makeRequest(0);\n  });\n\n  promise.on = (event, fn) => {\n    emitter.on(event, fn);\n    return promise;\n  };\n\n  const shortcut = responseType => {\n    const newPromise = (async () => {\n      // Wait until downloading has ended\n      await promise;\n      const {\n        options\n      } = globalResponse.request;\n      return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n    })();\n\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n\n  promise.json = () => {\n    const {\n      headers\n    } = globalRequest.options;\n\n    if (!globalRequest.writableFinished && headers.accept === undefined) {\n      headers.accept = 'application/json';\n    }\n\n    return shortcut('json');\n  };\n\n  promise.buffer = () => shortcut('buffer');\n\n  promise.text = () => shortcut('text');\n\n  return promise;\n}\n\nexports.default = asPromise;\n\n__exportStar(require(\"./types\"), exports);","map":{"version":3,"sources":["/home/td/code/up-frontend-mvp/node_modules/got/dist/source/as-promise/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__exportStar","exports","p","prototype","hasOwnProperty","call","value","events_1","require","is_1","PCancelable","types_1","parse_body_1","core_1","proxy_events_1","get_buffer_1","is_response_ok_1","proxiedRequestEvents","asPromise","normalizedOptions","globalRequest","globalResponse","emitter","EventEmitter","promise","resolve","reject","onCancel","makeRequest","retryCount","request","default","_noPipe","destroy","shouldReject","CancelError","once","response","_a","aborted","rawBody","_b","_isAboutToError","contentEncoding","headers","toLowerCase","isCompressed","includes","options","decompress","body","responseType","parseJson","encoding","error","toString","isResponseOk","_beforeError","index","hook","hooks","afterResponse","entries","updatedOptions","typedOptions","normalizeArguments","retry","calculateDelay","throwHttpErrors","resolveBodyOnly","slice","beforeRetry","catch","cancel","RequestError","message","HTTPError","onError","isCanceled","previousBody","newRetryCount","nodeStream","on","event","fn","shortcut","newPromise","defineProperties","getOwnPropertyDescriptors","json","writableFinished","accept","buffer","text"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst PCancelable = require(\"p-cancelable\");\nconst types_1 = require(\"./types\");\nconst parse_body_1 = require(\"./parse-body\");\nconst core_1 = require(\"../core\");\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\nconst is_response_ok_1 = require(\"../core/utils/is-response-ok\");\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress'\n];\nfunction asPromise(normalizedOptions) {\n    let globalRequest;\n    let globalResponse;\n    const emitter = new events_1.EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        const makeRequest = (retryCount) => {\n            const request = new core_1.default(undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            onCancel(() => request.destroy());\n            onCancel.shouldReject = false;\n            onCancel(() => reject(new types_1.CancelError(request)));\n            globalRequest = request;\n            request.once('response', async (response) => {\n                var _a;\n                response.retryCount = retryCount;\n                if (response.request.aborted) {\n                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                    return;\n                }\n                // Download body\n                let rawBody;\n                try {\n                    rawBody = await get_buffer_1.default(request);\n                    response.rawBody = rawBody;\n                }\n                catch (_b) {\n                    // The same error is caught below.\n                    // See request.once('error')\n                    return;\n                }\n                if (request._isAboutToError) {\n                    return;\n                }\n                // Parse body\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = rawBody;\n                }\n                else {\n                    try {\n                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fallback to `utf8`\n                        response.body = rawBody.toString();\n                        if (is_response_ok_1.isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            const typedOptions = core_1.default.normalizeArguments(undefined, {\n                                ...updatedOptions,\n                                retry: {\n                                    calculateDelay: () => 0\n                                },\n                                throwHttpErrors: false,\n                                resolveBodyOnly: false\n                            }, options);\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n                            for (const hook of typedOptions.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(typedOptions);\n                            }\n                            const promise = asPromise(typedOptions);\n                            onCancel(() => {\n                                promise.catch(() => { });\n                                promise.cancel();\n                            });\n                            return promise;\n                        });\n                    }\n                }\n                catch (error) {\n                    request._beforeError(new types_1.RequestError(error.message, error, request));\n                    return;\n                }\n                if (!is_response_ok_1.isResponseOk(response)) {\n                    request._beforeError(new types_1.HTTPError(response));\n                    return;\n                }\n                globalResponse = response;\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options.body;\n            request.once('retry', (newRetryCount, error) => {\n                var _a, _b;\n                if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n                    onError(error);\n                    return;\n                }\n                makeRequest(newRetryCount);\n            });\n            proxy_events_1.default(request, emitter, proxiedRequestEvents);\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        const { headers } = globalRequest.options;\n        if (!globalRequest.writableFinished && headers.accept === undefined) {\n            headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports.default = asPromise;\n__exportStar(require(\"./types\"), exports);\n"]},"metadata":{},"sourceType":"script"}