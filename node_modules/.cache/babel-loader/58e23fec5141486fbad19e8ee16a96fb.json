{"ast":null,"code":"'use strict';\n\nconst http2 = require('http2');\n\nconst {\n  Writable\n} = require('stream');\n\nconst {\n  Agent,\n  globalAgent\n} = require('./agent');\n\nconst IncomingMessage = require('./incoming-message');\n\nconst urlToOptions = require('./utils/url-to-options');\n\nconst proxyEvents = require('./utils/proxy-events');\n\nconst isRequestPseudoHeader = require('./utils/is-request-pseudo-header');\n\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_PROTOCOL,\n  ERR_HTTP_HEADERS_SENT,\n  ERR_INVALID_HTTP_TOKEN,\n  ERR_HTTP_INVALID_HEADER_VALUE,\n  ERR_INVALID_CHAR\n} = require('./utils/errors');\n\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_METHOD_CONNECT\n} = http2.constants;\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\nconst isValidHttpToken = /^[\\^`\\-\\w!#$%&*+.|~]+$/;\nconst isInvalidHeaderValue = /[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/;\n\nclass ClientRequest extends Writable {\n  constructor(input, options, callback) {\n    super({\n      autoDestroy: false\n    });\n    const hasInput = typeof input === 'string' || input instanceof URL;\n\n    if (hasInput) {\n      input = urlToOptions(input instanceof URL ? input : new URL(input));\n    }\n\n    if (typeof options === 'function' || options === undefined) {\n      // (options, callback)\n      callback = options;\n      options = hasInput ? input : { ...input\n      };\n    } else {\n      // (input, options, callback)\n      options = { ...input,\n        ...options\n      };\n    }\n\n    if (options.h2session) {\n      this[kSession] = options.h2session;\n    } else if (options.agent === false) {\n      this.agent = new Agent({\n        maxFreeSessions: 0\n      });\n    } else if (typeof options.agent === 'undefined' || options.agent === null) {\n      if (typeof options.createConnection === 'function') {\n        // This is a workaround - we don't have to create the session on our own.\n        this.agent = new Agent({\n          maxFreeSessions: 0\n        });\n        this.agent.createConnection = options.createConnection;\n      } else {\n        this.agent = globalAgent;\n      }\n    } else if (typeof options.agent.request === 'function') {\n      this.agent = options.agent;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);\n    }\n\n    if (options.protocol && options.protocol !== 'https:') {\n      throw new ERR_INVALID_PROTOCOL(options.protocol, 'https:');\n    }\n\n    const port = options.port || options.defaultPort || this.agent && this.agent.defaultPort || 443;\n    const host = options.hostname || options.host || 'localhost'; // Don't enforce the origin via options. It may be changed in an Agent.\n\n    delete options.hostname;\n    delete options.host;\n    delete options.port;\n    const {\n      timeout\n    } = options;\n    options.timeout = undefined;\n    this[kHeaders] = Object.create(null);\n    this[kJobs] = [];\n    this.socket = null;\n    this.connection = null;\n    this.method = options.method || 'GET';\n    this.path = options.path;\n    this.res = null;\n    this.aborted = false;\n    this.reusedSocket = false;\n\n    if (options.headers) {\n      for (const [header, value] of Object.entries(options.headers)) {\n        this.setHeader(header, value);\n      }\n    }\n\n    if (options.auth && !('authorization' in this[kHeaders])) {\n      this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n    }\n\n    options.session = options.tlsSession;\n    options.path = options.socketPath;\n    this[kOptions] = options; // Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\n    if (port === 443) {\n      this[kOrigin] = `https://${host}`;\n\n      if (!(':authority' in this[kHeaders])) {\n        this[kHeaders][':authority'] = host;\n      }\n    } else {\n      this[kOrigin] = `https://${host}:${port}`;\n\n      if (!(':authority' in this[kHeaders])) {\n        this[kHeaders][':authority'] = `${host}:${port}`;\n      }\n    }\n\n    if (timeout) {\n      this.setTimeout(timeout);\n    }\n\n    if (callback) {\n      this.once('response', callback);\n    }\n\n    this[kFlushedHeaders] = false;\n  }\n\n  get method() {\n    return this[kHeaders][HTTP2_HEADER_METHOD];\n  }\n\n  set method(value) {\n    if (value) {\n      this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n    }\n  }\n\n  get path() {\n    return this[kHeaders][HTTP2_HEADER_PATH];\n  }\n\n  set path(value) {\n    if (value) {\n      this[kHeaders][HTTP2_HEADER_PATH] = value;\n    }\n  }\n\n  get _mustNotHaveABody() {\n    return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n  }\n\n  _write(chunk, encoding, callback) {\n    // https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n    if (this._mustNotHaveABody) {\n      callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n      /* istanbul ignore next: Node.js 12 throws directly */\n\n      return;\n    }\n\n    this.flushHeaders();\n\n    const callWrite = () => this._request.write(chunk, encoding, callback);\n\n    if (this._request) {\n      callWrite();\n    } else {\n      this[kJobs].push(callWrite);\n    }\n  }\n\n  _final(callback) {\n    if (this.destroyed) {\n      return;\n    }\n\n    this.flushHeaders();\n\n    const callEnd = () => {\n      // For GET, HEAD and DELETE\n      if (this._mustNotHaveABody) {\n        callback();\n        return;\n      }\n\n      this._request.end(callback);\n    };\n\n    if (this._request) {\n      callEnd();\n    } else {\n      this[kJobs].push(callEnd);\n    }\n  }\n\n  abort() {\n    if (this.res && this.res.complete) {\n      return;\n    }\n\n    if (!this.aborted) {\n      process.nextTick(() => this.emit('abort'));\n    }\n\n    this.aborted = true;\n    this.destroy();\n  }\n\n  _destroy(error, callback) {\n    if (this.res) {\n      this.res._dump();\n    }\n\n    if (this._request) {\n      this._request.destroy();\n    }\n\n    callback(error);\n  }\n\n  async flushHeaders() {\n    if (this[kFlushedHeaders] || this.destroyed) {\n      return;\n    }\n\n    this[kFlushedHeaders] = true;\n    const isConnectMethod = this.method === HTTP2_METHOD_CONNECT; // The real magic is here\n\n    const onStream = stream => {\n      this._request = stream;\n\n      if (this.destroyed) {\n        stream.destroy();\n        return;\n      } // Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\n\n      if (!isConnectMethod) {\n        proxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);\n      } // Wait for the `finish` event. We don't want to emit the `response` event\n      // before `request.end()` is called.\n\n\n      const waitForEnd = fn => {\n        return (...args) => {\n          if (!this.writable && !this.destroyed) {\n            fn(...args);\n          } else {\n            this.once('finish', () => {\n              fn(...args);\n            });\n          }\n        };\n      }; // This event tells we are ready to listen for the data.\n\n\n      stream.once('response', waitForEnd((headers, flags, rawHeaders) => {\n        // If we were to emit raw request stream, it would be as fast as the native approach.\n        // Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n        const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n        this.res = response;\n        response.req = this;\n        response.statusCode = headers[HTTP2_HEADER_STATUS];\n        response.headers = headers;\n        response.rawHeaders = rawHeaders;\n        response.once('end', () => {\n          if (this.aborted) {\n            response.aborted = true;\n            response.emit('aborted');\n          } else {\n            response.complete = true; // Has no effect, just be consistent with the Node.js behavior\n\n            response.socket = null;\n            response.connection = null;\n          }\n        });\n\n        if (isConnectMethod) {\n          response.upgrade = true; // The HTTP1 API says the socket is detached here,\n          // but we can't do that so we pass the original HTTP2 request.\n\n          if (this.emit('connect', response, stream, Buffer.alloc(0))) {\n            this.emit('close');\n          } else {\n            // No listeners attached, destroy the original request.\n            stream.destroy();\n          }\n        } else {\n          // Forwards data\n          stream.on('data', chunk => {\n            if (!response._dumped && !response.push(chunk)) {\n              stream.pause();\n            }\n          });\n          stream.once('end', () => {\n            response.push(null);\n          });\n\n          if (!this.emit('response', response)) {\n            // No listeners attached, dump the response.\n            response._dump();\n          }\n        }\n      })); // Emits `information` event\n\n      stream.once('headers', waitForEnd(headers => this.emit('information', {\n        statusCode: headers[HTTP2_HEADER_STATUS]\n      })));\n      stream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {\n        const {\n          res\n        } = this; // Assigns trailers to the response object.\n\n        res.trailers = trailers;\n        res.rawTrailers = rawTrailers;\n      }));\n      const {\n        socket\n      } = stream.session;\n      this.socket = socket;\n      this.connection = socket;\n\n      for (const job of this[kJobs]) {\n        job();\n      }\n\n      this.emit('socket', this.socket);\n    }; // Makes a HTTP2 request\n\n\n    if (this[kSession]) {\n      try {\n        onStream(this[kSession].request(this[kHeaders]));\n      } catch (error) {\n        this.emit('error', error);\n      }\n    } else {\n      this.reusedSocket = true;\n\n      try {\n        onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n  }\n\n  getHeader(name) {\n    if (typeof name !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n    }\n\n    return this[kHeaders][name.toLowerCase()];\n  }\n\n  get headersSent() {\n    return this[kFlushedHeaders];\n  }\n\n  removeHeader(name) {\n    if (typeof name !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n    }\n\n    if (this.headersSent) {\n      throw new ERR_HTTP_HEADERS_SENT('remove');\n    }\n\n    delete this[kHeaders][name.toLowerCase()];\n  }\n\n  setHeader(name, value) {\n    if (this.headersSent) {\n      throw new ERR_HTTP_HEADERS_SENT('set');\n    }\n\n    if (typeof name !== 'string' || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {\n      throw new ERR_INVALID_HTTP_TOKEN('Header name', name);\n    }\n\n    if (typeof value === 'undefined') {\n      throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);\n    }\n\n    if (isInvalidHeaderValue.test(value)) {\n      throw new ERR_INVALID_CHAR('header content', name);\n    }\n\n    this[kHeaders][name.toLowerCase()] = value;\n  }\n\n  setNoDelay() {// HTTP2 sockets cannot be malformed, do nothing.\n  }\n\n  setSocketKeepAlive() {// HTTP2 sockets cannot be malformed, do nothing.\n  }\n\n  setTimeout(ms, callback) {\n    const applyTimeout = () => this._request.setTimeout(ms, callback);\n\n    if (this._request) {\n      applyTimeout();\n    } else {\n      this[kJobs].push(applyTimeout);\n    }\n\n    return this;\n  }\n\n  get maxHeadersCount() {\n    if (!this.destroyed && this._request) {\n      return this._request.session.localSettings.maxHeaderListSize;\n    }\n\n    return undefined;\n  }\n\n  set maxHeadersCount(_value) {// Updating HTTP2 settings would affect all requests, do nothing.\n  }\n\n}\n\nmodule.exports = ClientRequest;","map":{"version":3,"sources":["/home/td/code/up-frontend-mvp/node_modules/http2-wrapper/source/client-request.js"],"names":["http2","require","Writable","Agent","globalAgent","IncomingMessage","urlToOptions","proxyEvents","isRequestPseudoHeader","ERR_INVALID_ARG_TYPE","ERR_INVALID_PROTOCOL","ERR_HTTP_HEADERS_SENT","ERR_INVALID_HTTP_TOKEN","ERR_HTTP_INVALID_HEADER_VALUE","ERR_INVALID_CHAR","HTTP2_HEADER_STATUS","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_METHOD_CONNECT","constants","kHeaders","Symbol","kOrigin","kSession","kOptions","kFlushedHeaders","kJobs","isValidHttpToken","isInvalidHeaderValue","ClientRequest","constructor","input","options","callback","autoDestroy","hasInput","URL","undefined","h2session","agent","maxFreeSessions","createConnection","request","protocol","port","defaultPort","host","hostname","timeout","Object","create","socket","connection","method","path","res","aborted","reusedSocket","headers","header","value","entries","setHeader","auth","authorization","Buffer","from","toString","session","tlsSession","socketPath","setTimeout","once","toUpperCase","_mustNotHaveABody","_write","chunk","encoding","Error","flushHeaders","callWrite","_request","write","push","_final","destroyed","callEnd","end","abort","complete","process","nextTick","emit","destroy","_destroy","error","_dump","isConnectMethod","onStream","stream","waitForEnd","fn","args","writable","flags","rawHeaders","response","readableHighWaterMark","req","statusCode","upgrade","alloc","on","_dumped","pause","trailers","rawTrailers","job","getHeader","name","toLowerCase","headersSent","removeHeader","test","setNoDelay","setSocketKeepAlive","ms","applyTimeout","maxHeadersCount","localSettings","maxHeaderListSize","_value","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst http2 = require('http2');\nconst {Writable} = require('stream');\nconst {Agent, globalAgent} = require('./agent');\nconst IncomingMessage = require('./incoming-message');\nconst urlToOptions = require('./utils/url-to-options');\nconst proxyEvents = require('./utils/proxy-events');\nconst isRequestPseudoHeader = require('./utils/is-request-pseudo-header');\nconst {\n\tERR_INVALID_ARG_TYPE,\n\tERR_INVALID_PROTOCOL,\n\tERR_HTTP_HEADERS_SENT,\n\tERR_INVALID_HTTP_TOKEN,\n\tERR_HTTP_INVALID_HEADER_VALUE,\n\tERR_INVALID_CHAR\n} = require('./utils/errors');\n\nconst {\n\tHTTP2_HEADER_STATUS,\n\tHTTP2_HEADER_METHOD,\n\tHTTP2_HEADER_PATH,\n\tHTTP2_METHOD_CONNECT\n} = http2.constants;\n\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\n\nconst isValidHttpToken = /^[\\^`\\-\\w!#$%&*+.|~]+$/;\nconst isInvalidHeaderValue = /[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/;\n\nclass ClientRequest extends Writable {\n\tconstructor(input, options, callback) {\n\t\tsuper({\n\t\t\tautoDestroy: false\n\t\t});\n\n\t\tconst hasInput = typeof input === 'string' || input instanceof URL;\n\t\tif (hasInput) {\n\t\t\tinput = urlToOptions(input instanceof URL ? input : new URL(input));\n\t\t}\n\n\t\tif (typeof options === 'function' || options === undefined) {\n\t\t\t// (options, callback)\n\t\t\tcallback = options;\n\t\t\toptions = hasInput ? input : {...input};\n\t\t} else {\n\t\t\t// (input, options, callback)\n\t\t\toptions = {...input, ...options};\n\t\t}\n\n\t\tif (options.h2session) {\n\t\t\tthis[kSession] = options.h2session;\n\t\t} else if (options.agent === false) {\n\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t} else if (typeof options.agent === 'undefined' || options.agent === null) {\n\t\t\tif (typeof options.createConnection === 'function') {\n\t\t\t\t// This is a workaround - we don't have to create the session on our own.\n\t\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t\t\tthis.agent.createConnection = options.createConnection;\n\t\t\t} else {\n\t\t\t\tthis.agent = globalAgent;\n\t\t\t}\n\t\t} else if (typeof options.agent.request === 'function') {\n\t\t\tthis.agent = options.agent;\n\t\t} else {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);\n\t\t}\n\n\t\tif (options.protocol && options.protocol !== 'https:') {\n\t\t\tthrow new ERR_INVALID_PROTOCOL(options.protocol, 'https:');\n\t\t}\n\n\t\tconst port = options.port || options.defaultPort || (this.agent && this.agent.defaultPort) || 443;\n\t\tconst host = options.hostname || options.host || 'localhost';\n\n\t\t// Don't enforce the origin via options. It may be changed in an Agent.\n\t\tdelete options.hostname;\n\t\tdelete options.host;\n\t\tdelete options.port;\n\n\t\tconst {timeout} = options;\n\t\toptions.timeout = undefined;\n\n\t\tthis[kHeaders] = Object.create(null);\n\t\tthis[kJobs] = [];\n\n\t\tthis.socket = null;\n\t\tthis.connection = null;\n\n\t\tthis.method = options.method || 'GET';\n\t\tthis.path = options.path;\n\n\t\tthis.res = null;\n\t\tthis.aborted = false;\n\t\tthis.reusedSocket = false;\n\n\t\tif (options.headers) {\n\t\t\tfor (const [header, value] of Object.entries(options.headers)) {\n\t\t\t\tthis.setHeader(header, value);\n\t\t\t}\n\t\t}\n\n\t\tif (options.auth && !('authorization' in this[kHeaders])) {\n\t\t\tthis[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n\t\t}\n\n\t\toptions.session = options.tlsSession;\n\t\toptions.path = options.socketPath;\n\n\t\tthis[kOptions] = options;\n\n\t\t// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\t\tif (port === 443) {\n\t\t\tthis[kOrigin] = `https://${host}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = host;\n\t\t\t}\n\t\t} else {\n\t\t\tthis[kOrigin] = `https://${host}:${port}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = `${host}:${port}`;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tthis.setTimeout(timeout);\n\t\t}\n\n\t\tif (callback) {\n\t\t\tthis.once('response', callback);\n\t\t}\n\n\t\tthis[kFlushedHeaders] = false;\n\t}\n\n\tget method() {\n\t\treturn this[kHeaders][HTTP2_HEADER_METHOD];\n\t}\n\n\tset method(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn this[kHeaders][HTTP2_HEADER_PATH];\n\t}\n\n\tset path(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_PATH] = value;\n\t\t}\n\t}\n\n\tget _mustNotHaveABody() {\n\t\treturn this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n\t}\n\n\t_write(chunk, encoding, callback) {\n\t\t// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n\t\tif (this._mustNotHaveABody) {\n\t\t\tcallback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n\t\t\t/* istanbul ignore next: Node.js 12 throws directly */\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callWrite = () => this._request.write(chunk, encoding, callback);\n\t\tif (this._request) {\n\t\t\tcallWrite();\n\t\t} else {\n\t\t\tthis[kJobs].push(callWrite);\n\t\t}\n\t}\n\n\t_final(callback) {\n\t\tif (this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callEnd = () => {\n\t\t\t// For GET, HEAD and DELETE\n\t\t\tif (this._mustNotHaveABody) {\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._request.end(callback);\n\t\t};\n\n\t\tif (this._request) {\n\t\t\tcallEnd();\n\t\t} else {\n\t\t\tthis[kJobs].push(callEnd);\n\t\t}\n\t}\n\n\tabort() {\n\t\tif (this.res && this.res.complete) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.aborted) {\n\t\t\tprocess.nextTick(() => this.emit('abort'));\n\t\t}\n\n\t\tthis.aborted = true;\n\n\t\tthis.destroy();\n\t}\n\n\t_destroy(error, callback) {\n\t\tif (this.res) {\n\t\t\tthis.res._dump();\n\t\t}\n\n\t\tif (this._request) {\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tcallback(error);\n\t}\n\n\tasync flushHeaders() {\n\t\tif (this[kFlushedHeaders] || this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis[kFlushedHeaders] = true;\n\n\t\tconst isConnectMethod = this.method === HTTP2_METHOD_CONNECT;\n\n\t\t// The real magic is here\n\t\tconst onStream = stream => {\n\t\t\tthis._request = stream;\n\n\t\t\tif (this.destroyed) {\n\t\t\t\tstream.destroy();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\t\t\tif (!isConnectMethod) {\n\t\t\t\tproxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);\n\t\t\t}\n\n\t\t\t// Wait for the `finish` event. We don't want to emit the `response` event\n\t\t\t// before `request.end()` is called.\n\t\t\tconst waitForEnd = fn => {\n\t\t\t\treturn (...args) => {\n\t\t\t\t\tif (!this.writable && !this.destroyed) {\n\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.once('finish', () => {\n\t\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// This event tells we are ready to listen for the data.\n\t\t\tstream.once('response', waitForEnd((headers, flags, rawHeaders) => {\n\t\t\t\t// If we were to emit raw request stream, it would be as fast as the native approach.\n\t\t\t\t// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n\t\t\t\tconst response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n\t\t\t\tthis.res = response;\n\n\t\t\t\tresponse.req = this;\n\t\t\t\tresponse.statusCode = headers[HTTP2_HEADER_STATUS];\n\t\t\t\tresponse.headers = headers;\n\t\t\t\tresponse.rawHeaders = rawHeaders;\n\n\t\t\t\tresponse.once('end', () => {\n\t\t\t\t\tif (this.aborted) {\n\t\t\t\t\t\tresponse.aborted = true;\n\t\t\t\t\t\tresponse.emit('aborted');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.complete = true;\n\n\t\t\t\t\t\t// Has no effect, just be consistent with the Node.js behavior\n\t\t\t\t\t\tresponse.socket = null;\n\t\t\t\t\t\tresponse.connection = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (isConnectMethod) {\n\t\t\t\t\tresponse.upgrade = true;\n\n\t\t\t\t\t// The HTTP1 API says the socket is detached here,\n\t\t\t\t\t// but we can't do that so we pass the original HTTP2 request.\n\t\t\t\t\tif (this.emit('connect', response, stream, Buffer.alloc(0))) {\n\t\t\t\t\t\tthis.emit('close');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No listeners attached, destroy the original request.\n\t\t\t\t\t\tstream.destroy();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Forwards data\n\t\t\t\t\tstream.on('data', chunk => {\n\t\t\t\t\t\tif (!response._dumped && !response.push(chunk)) {\n\t\t\t\t\t\t\tstream.pause();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.once('end', () => {\n\t\t\t\t\t\tresponse.push(null);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!this.emit('response', response)) {\n\t\t\t\t\t\t// No listeners attached, dump the response.\n\t\t\t\t\t\tresponse._dump();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\t// Emits `information` event\n\t\t\tstream.once('headers', waitForEnd(\n\t\t\t\theaders => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]})\n\t\t\t));\n\n\t\t\tstream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {\n\t\t\t\tconst {res} = this;\n\n\t\t\t\t// Assigns trailers to the response object.\n\t\t\t\tres.trailers = trailers;\n\t\t\t\tres.rawTrailers = rawTrailers;\n\t\t\t}));\n\n\t\t\tconst {socket} = stream.session;\n\t\t\tthis.socket = socket;\n\t\t\tthis.connection = socket;\n\n\t\t\tfor (const job of this[kJobs]) {\n\t\t\t\tjob();\n\t\t\t}\n\n\t\t\tthis.emit('socket', this.socket);\n\t\t};\n\n\t\t// Makes a HTTP2 request\n\t\tif (this[kSession]) {\n\t\t\ttry {\n\t\t\t\tonStream(this[kSession].request(this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.reusedSocket = true;\n\n\t\t\ttry {\n\t\t\t\tonStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\treturn this[kHeaders][name.toLowerCase()];\n\t}\n\n\tget headersSent() {\n\t\treturn this[kFlushedHeaders];\n\t}\n\n\tremoveHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('remove');\n\t\t}\n\n\t\tdelete this[kHeaders][name.toLowerCase()];\n\t}\n\n\tsetHeader(name, value) {\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('set');\n\t\t}\n\n\t\tif (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {\n\t\t\tthrow new ERR_INVALID_HTTP_TOKEN('Header name', name);\n\t\t}\n\n\t\tif (typeof value === 'undefined') {\n\t\t\tthrow new ERR_HTTP_INVALID_HEADER_VALUE(value, name);\n\t\t}\n\n\t\tif (isInvalidHeaderValue.test(value)) {\n\t\t\tthrow new ERR_INVALID_CHAR('header content', name);\n\t\t}\n\n\t\tthis[kHeaders][name.toLowerCase()] = value;\n\t}\n\n\tsetNoDelay() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetSocketKeepAlive() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetTimeout(ms, callback) {\n\t\tconst applyTimeout = () => this._request.setTimeout(ms, callback);\n\n\t\tif (this._request) {\n\t\t\tapplyTimeout();\n\t\t} else {\n\t\t\tthis[kJobs].push(applyTimeout);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tget maxHeadersCount() {\n\t\tif (!this.destroyed && this._request) {\n\t\t\treturn this._request.session.localSettings.maxHeaderListSize;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tset maxHeadersCount(_value) {\n\t\t// Updating HTTP2 settings would affect all requests, do nothing.\n\t}\n}\n\nmodule.exports = ClientRequest;\n"]},"metadata":{},"sourceType":"script"}